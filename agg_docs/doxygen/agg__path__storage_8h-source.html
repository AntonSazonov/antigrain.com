<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>agg_path_storage.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.14 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>agg_path_storage.h</h1><a href="agg__path__storage_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <font class="comment">//----------------------------------------------------------------------------</font>
00002 <font class="comment">// Anti-Grain Geometry - Version 2.0 </font>
00003 <font class="comment">// Copyright (C) 2002 Maxim Shemanarev (McSeem)</font>
00004 <font class="comment">//</font>
00005 <font class="comment">// Permission to copy, use, modify, sell and distribute this software </font>
00006 <font class="comment">// is granted provided this copyright notice appears in all copies. </font>
00007 <font class="comment">// This software is provided "as is" without express or implied</font>
00008 <font class="comment">// warranty, and with no claim as to its suitability for any purpose.</font>
00009 <font class="comment">//</font>
00010 <font class="comment">//----------------------------------------------------------------------------</font>
00011 <font class="comment">// Contact: mcseem@antigrain.com</font>
00012 <font class="comment">//          mcseemagg@yahoo.com</font>
00013 <font class="comment">//          http://www.antigrain.com</font>
00014 <font class="comment">//----------------------------------------------------------------------------</font>
00015 <font class="comment">//</font>
00016 <font class="comment">// class path_storage</font>
00017 <font class="comment">//</font>
00018 <font class="comment">//----------------------------------------------------------------------------</font>
00019 <font class="preprocessor">#ifndef AGG_PATH_STORAGE_INCLUDED</font>
00020 <font class="preprocessor"></font><font class="preprocessor">#define AGG_PATH_STORAGE_INCLUDED</font>
00021 <font class="preprocessor"></font>
00022 <font class="preprocessor">#include "<a class="code" href="agg__basics_8h.html">agg_basics.h</a>"</font>
00023 <font class="preprocessor">#include "<a class="code" href="agg__pipe__conv_8h.html">agg_pipe_conv.h</a>"</font>
00024 
00025 
00026 <font class="keyword">namespace </font>agg
00027 {
00028     <font class="comment">//------------------------------------------------------------------------</font>
00029     <font class="comment">// A concept of vertex sources and pipelines.</font>
00030     <font class="comment">//</font>
00031     <font class="comment">// Before rendering anything we must collect and store the necessary number </font>
00032     <font class="comment">// of vertices. There different approaches can be used, for example,</font>
00033     <font class="comment">// simple buffer in memory. But we also may want to perform different</font>
00034     <font class="comment">// kinds of transformations, for example, affine transformations, clipping,</font>
00035     <font class="comment">// making an outline, calculation Minkowski sum, and so on.  Many graphic</font>
00036     <font class="comment">// libraries do that, but the sequence of transformations is often </font>
00037     <font class="comment">// hardcoded, i.e., there's a number of settings such as set_rotate(), </font>
00038     <font class="comment">// set_clip_box(), etc, which can be used or ommited, but anyway a particular</font>
00039     <font class="comment">// vertex suffers all these transformations in a strictly defined order.</font>
00040     <font class="comment">// Another approach is based on a number of functions (or classes) that </font>
00041     <font class="comment">// perform only one kind of transformations. In this case we have to use</font>
00042     <font class="comment">// a storage on each step (say, a several vertex arrays), because we have</font>
00043     <font class="comment">// to store intermediate results. </font>
00044     <font class="comment">//</font>
00045     <font class="comment">// AGG allows you to construct any custom pipelines, but at the same time </font>
00046     <font class="comment">// does not require the use of any intermediate storages. Not possible?</font>
00047     <font class="comment">// Yes, it is possible with some exceptions which are not painful.</font>
00048     <font class="comment">// </font>
00049     <font class="comment">// A concept of rendering assumes creating an object agg::polyfill, then</font>
00050     <font class="comment">// adding vertices into it, and finally render the filled polygon. There's</font>
00051     <font class="comment">// a number of template functions, such as make_polygon, render_path, etc, </font>
00052     <font class="comment">// that accept an abstract storage as a source of vertices and "ask" it to </font>
00053     <font class="comment">// give vertices one after another. This storage must support the interface</font>
00054     <font class="comment">// of two methods: reset_iterator() and next_vertex(). The latest method </font>
00055     <font class="comment">// gives one vertex from the storage and return special flag.</font>
00056     <font class="comment">//</font>
00057     <font class="comment">// When all verices are given, method next_vertex() returns flag pathflag_stop. </font>
00058     <font class="comment">// Such a concept allows you to avoid storing vertices anywhere,</font>
00059     <font class="comment">// in case, for example, if you know the analitical representation of your</font>
00060     <font class="comment">// figure and calculate vertices on demand. For example, we can</font>
00061     <font class="comment">// easily write a class that makes sinewave, but does not use any arrays. This</font>
00062     <font class="comment">// class can be used as a source of vertices either directly or via some</font>
00063     <font class="comment">// intermediate converters. The examples of such kind of classes you can find</font>
00064     <font class="comment">// in file agg_curves.h.</font>
00065     <font class="comment">//</font>
00066     <font class="comment">// The main conclusion of it is: Any class that supports interface of two </font>
00067     <font class="comment">// mentioned above methods can be used as a vertex source.</font>
00068     <font class="comment">//</font>
00069     <font class="comment">// There're two kinds of these classes - initial sources and intermediate </font>
00070     <font class="comment">// converters. The latest require a pointer to a preceeding source when</font>
00071     <font class="comment">// being constructed. All these classes have prefix "conv_". Classes </font>
00072     <font class="comment">// path_storage, curve3, curve4 can be only initial sources.</font>
00073     <font class="comment">//</font>
00074     <font class="comment">// All converter classes are template ones, all initial sources are usualy </font>
00075     <font class="comment">// regular ones. Template mechanism us used because it gives us more freedom.</font>
00076     <font class="comment">// All the vertex source class need to have is three-method interface. These</font>
00077     <font class="comment">// classes don't have to be derived from any particular base class, and, </font>
00078     <font class="comment">// besides, it allows us to avoid using virtual calls which works much</font>
00079     <font class="comment">// slower than regular calls (They make the processor pipeline to resynchronize</font>
00080     <font class="comment">// because they are doubly indirect. BTW, pure C indirect calls, via a pointer</font>
00081     <font class="comment">// to a function work almost as fast as direct ones, because they have only</font>
00082     <font class="comment">// one level of indirection).</font>
00083     <font class="comment">//</font>
00084     <font class="comment">// Still, sometimes we have to use converters that have one common base</font>
00085     <font class="comment">// class and their interface methods are virtual. There is such base class</font>
00086     <font class="comment">// called pipe_conv. See agg_pipe_conv.h for details. In fact there's only </font>
00087     <font class="comment">// wrappers that turn interface function into virtual. Every vertex source </font>
00088     <font class="comment">// class has this wrapper.</font>
00089     <font class="comment">//------------------------------------------------------------------------</font>
00090     
00091 
00092     <font class="keyword">const</font> <font class="keywordtype">double</font> <a class="code" href="namespaceagg.html#a34">filter_epsilon_pos</a> =  0.001;
00093 
00094     <font class="comment">//------------------------------------------------------------------------</font>
<a name="l00095"></a><a class="code" href="classagg_1_1path__storage.html">00095</a>     <font class="keyword">class </font>path_storage
00096     {
00097         <font class="comment">// Allocation parameters</font>
00098         <font class="keyword">enum</font>
00099         {
00100             <a class="code" href="classagg_1_1path__storage.html#u4u0">block_shift</a> = 8,
00101             <a class="code" href="classagg_1_1path__storage.html#u4u1">block_size</a> = 1 &lt;&lt; <a class="code" href="classagg_1_1path__storage.html#u4u0">block_shift</a>,
00102             <a class="code" href="classagg_1_1path__storage.html#u4u2">block_mask</a> = <a class="code" href="classagg_1_1path__storage.html#u4u1">block_size</a> - 1,
00103             <a class="code" href="classagg_1_1path__storage.html#u4u3">block_pool</a> = 256
00104         };
00105 
00106     <font class="keyword">public</font>:
00107         <a class="code" href="classagg_1_1path__storage.html#a0">~path_storage</a>();
00108         <a class="code" href="classagg_1_1path__storage.html#a1">path_storage</a>();
00109         <a class="code" href="classagg_1_1path__storage.html#a1">path_storage</a>(<font class="keyword">const</font> <a class="code" href="classagg_1_1path__storage.html#a1">path_storage</a>&amp; ps);
00110 
00111         <font class="keywordtype">void</font> <a class="code" href="classagg_1_1path__storage.html#a3">remove_all</a>();
00112 
00113         <font class="keywordtype">void</font> <a class="code" href="classagg_1_1path__storage.html#a4">move_to</a>(<font class="keywordtype">double</font> x, <font class="keywordtype">double</font> y, 
00114                      <a class="code" href="namespaceagg.html#a64">orientation_e</a> orient=<a class="code" href="namespaceagg.html#a64a30">orientation_unknown</a>);
00115 
00116         <font class="keywordtype">void</font> <a class="code" href="classagg_1_1path__storage.html#a5">line_to</a>(<font class="keywordtype">double</font> x, <font class="keywordtype">double</font> y);
00117 
00118         <font class="keywordtype">void</font> <a class="code" href="classagg_1_1path__storage.html#a6">curve3</a>(<font class="keywordtype">double</font> x_ctrl,  <font class="keywordtype">double</font> y_ctrl, 
00119                     <font class="keywordtype">double</font> x_to,    <font class="keywordtype">double</font> y_to);
00120 
00121         <font class="keywordtype">void</font> <a class="code" href="classagg_1_1path__storage.html#a7">curve4</a>(<font class="keywordtype">double</font> x_ctrl1, <font class="keywordtype">double</font> y_ctrl1, 
00122                     <font class="keywordtype">double</font> x_ctrl2, <font class="keywordtype">double</font> y_ctrl2, 
00123                     <font class="keywordtype">double</font> x_to,    <font class="keywordtype">double</font> y_to);
00124 
00125         <font class="keywordtype">void</font> <a class="code" href="classagg_1_1path__storage.html#a8">add_poly</a>(<font class="keyword">const</font> <font class="keywordtype">double</font>* vertices, <font class="keywordtype">unsigned</font> num,
00126                       <a class="code" href="namespaceagg.html#a64">orientation_e</a> orient=<a class="code" href="namespaceagg.html#a64a30">orientation_unknown</a>);
00127 
00128         <font class="keywordtype">unsigned</font> <a class="code" href="classagg_1_1path__storage.html#a9">add_new_path</a>();
00129 
00130         <font class="keywordtype">void</font> <a class="code" href="classagg_1_1path__storage.html#a10">copy_from</a>(<font class="keyword">const</font> <a class="code" href="classagg_1_1path__storage.html#a1">path_storage</a>&amp; ps);
<a name="l00131"></a><a class="code" href="classagg_1_1path__storage.html#a11">00131</a>         <font class="keyword">const</font> <a class="code" href="classagg_1_1path__storage.html#a1">path_storage</a>&amp; <a class="code" href="classagg_1_1path__storage.html#a11">operator = </a>(<font class="keyword">const</font> <a class="code" href="classagg_1_1path__storage.html#a1">path_storage</a>&amp; ps)
00132         {
00133             <a class="code" href="classagg_1_1path__storage.html#a10">copy_from</a>(ps);
00134             <font class="keywordflow">return</font> *<font class="keyword">this</font>;
00135         }
00136 
<a name="l00137"></a><a class="code" href="classagg_1_1path__storage.html#a12">00137</a>         <font class="keywordtype">unsigned</font>   <a class="code" href="classagg_1_1path__storage.html#a12">total_vertices</a>()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <a class="code" href="classagg_1_1path__storage.html#o0">m_total_vertices</a>; }
00138         <a class="code" href="namespaceagg.html#a63">pathflag_e</a> <a class="code" href="classagg_1_1path__storage.html#a13">get_vertex</a>(<font class="keywordtype">unsigned</font> idx, <font class="keywordtype">double</font>* x, <font class="keywordtype">double</font>* y) <font class="keyword">const</font>;
<a name="l00139"></a><a class="code" href="classagg_1_1path__storage.html#a14">00139</a>         <a class="code" href="namespaceagg.html#a64">orientation_e</a> <a class="code" href="classagg_1_1path__storage.html#a14">get_orientation</a>()<font class="keyword"> const </font>{ <font class="keywordflow">return</font> <a class="code" href="classagg_1_1path__storage.html#o6">m_cur_orient</a>; }
00140 
00141         <font class="keywordtype">void</font> <a class="code" href="classagg_1_1path__storage.html#a15">reset_iterator</a>(<font class="keywordtype">unsigned</font> start);
00142         <a class="code" href="namespaceagg.html#a63">pathflag_e</a> <a class="code" href="classagg_1_1path__storage.html#a16">next_vertex</a>(<font class="keywordtype">double</font>* x, <font class="keywordtype">double</font>* y);
00143 
00144 
00145         <font class="comment">//=============================== Auxiliary useful functions</font>
00146         
00147         <font class="comment">// Removes all extra vertices lying on one straight line.</font>
00148         <font class="comment">// This method is used when it's critical for calculations,</font>
00149         <font class="comment">// for example, in conv_polygon and conv_polyline classes.</font>
00150         <font class="comment">// The method assumes that the storage contains exactly one </font>
00151         <font class="comment">// one path containing exactly one polygon.</font>
00152         <font class="keywordtype">void</font> <a class="code" href="classagg_1_1path__storage.html#a17">filter_vertices</a>(<font class="keywordtype">bool</font> closed);
00153 
00154         <font class="comment">// Get the bounding rectangle. It's auxiliary method which cal be</font>
00155         <font class="comment">// called only for all the paths in the storage.</font>
00156         <font class="keywordtype">void</font> <a class="code" href="classagg_1_1path__storage.html#a18">get_bound_rect</a>(<font class="keywordtype">double</font>* x1, <font class="keywordtype">double</font>* y1, <font class="keywordtype">double</font>* x2, <font class="keywordtype">double</font>* y2);
00157 
00158         <font class="comment">// Perception of polygons orientation - Clockwise or Counterclockwise.</font>
00159         <font class="comment">// The orientation flag is stored at every move_to vertex.</font>
00160         <font class="comment">// Returns the balance: </font>
00161         <font class="comment">// &gt; 0: the number of CCW polygons is greater than CW ones</font>
00162         <font class="comment">// &lt; 0: the number of CCW polygons is less than CW ones</font>
00163         <font class="keywordtype">int</font>  <a class="code" href="classagg_1_1path__storage.html#a19">perceive_orientation</a>(<font class="keywordtype">unsigned</font> start);
00164  
00165         <font class="comment">// Arrange the orientation of all the polygons. After calling this</font>
00166         <font class="comment">// method all the polygons will have the same orientation. </font>
00167         <font class="comment">// You have two options here - to perceive orientations before </font>
00168         <font class="comment">// arranging or rely on the ones that were passed into move_to()</font>
00169         <font class="comment">// mathod. If the perception_flag is true, argument new_orient has </font>
00170         <font class="comment">// the following meaning: if it signs the new orientation explicitely</font>
00171         <font class="comment">// (orientation_cw or orientation_ccw) this very orientation</font>
00172         <font class="comment">// will be set for all the polygons (the case when a particular </font>
00173         <font class="comment">// orientation is important). If its value is orientation_unknown </font>
00174         <font class="comment">// then the new orientation will be choosen automatically on the basis </font>
00175         <font class="comment">// of the minimal number of polygons that require reversing (the case when</font>
00176         <font class="comment">// all we need is to have all polygons with the same orientation, but</font>
00177         <font class="comment">// unimportant which one - this is actually the condition for class</font>
00178         <font class="comment">// outline to properly render with non-zero winding rule).</font>
00179         <font class="comment">// If perception_flag is false it means that we rely on the fact that</font>
00180         <font class="comment">// certain orientations were set explicitely (whether in move_to() or</font>
00181         <font class="comment">// with perceive_orientation()). Here if new_orientation is set to </font>
00182         <font class="comment">// orientation_unknown the method won't do anything. It will work only </font>
00183         <font class="comment">// if new_orient has a certain value (cw or ccw). But even in this case </font>
00184         <font class="comment">// only those polygons will be arranged whose orientation is known.</font>
00185         <font class="keywordtype">void</font> <a class="code" href="classagg_1_1path__storage.html#a20">arrange_orientation</a>(<font class="keywordtype">unsigned</font> start,
00186                                  <font class="keywordtype">bool</font> perception_flag=<font class="keyword">true</font>, 
00187                                  <a class="code" href="namespaceagg.html#a64">orientation_e</a> new_orient=<a class="code" href="namespaceagg.html#a64a30">orientation_unknown</a>);
00188         
00189         <font class="comment">// This function adds vertex with its flags directly. Since there's no </font>
00190         <font class="comment">// checking for errors, keeping proper path integrity is the responsibility</font>
00191         <font class="comment">// of the caller. It can be said the function is "not very public". It's</font>
00192         <font class="comment">// used in methods move_to, line_to and so on and also in polygon and </font>
00193         <font class="comment">// polyline converters.</font>
00194         <font class="keywordtype">void</font> <a class="code" href="classagg_1_1path__storage.html#a21">add_vertex</a>(<font class="keywordtype">double</font> x, <font class="keywordtype">double</font> y, <font class="keywordtype">unsigned</font> flag);
00195 
00196     <font class="keyword">private</font>:
00197         <font class="keywordtype">unsigned</font> <a class="code" href="classagg_1_1path__storage.html#c0">get_vertex_with_flags</a>(<font class="keywordtype">unsigned</font> idx, <font class="keywordtype">double</font>* x, <font class="keywordtype">double</font>* y) <font class="keyword">const</font>;
00198         <font class="keywordtype">bool</font> <a class="code" href="classagg_1_1path__storage.html#c1">filtered</a>(<font class="keywordtype">unsigned</font> prev, <font class="keywordtype">unsigned</font> curr, <font class="keywordtype">unsigned</font> next) <font class="keyword">const</font>;
00199         <font class="keywordtype">void</font> <a class="code" href="classagg_1_1path__storage.html#c2">copy_vertex</a>(<font class="keywordtype">unsigned</font> to, <font class="keywordtype">unsigned</font> from);
00200         <font class="keywordtype">void</font> <a class="code" href="classagg_1_1path__storage.html#c3">allocate_block</a>(<font class="keywordtype">unsigned</font> nb);
00201         <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>* <a class="code" href="classagg_1_1path__storage.html#c4">get_storage_ptrs</a>(<font class="keywordtype">double</font>** xy_ptr);
00202         <font class="keywordtype">unsigned</font> <a class="code" href="classagg_1_1path__storage.html#c5">perceive_polygon_orientation</a>(<font class="keywordtype">unsigned</font> idx, <font class="keywordtype">double</font> xs, <font class="keywordtype">double</font> ys);
00203         <font class="keywordtype">void</font> <a class="code" href="classagg_1_1path__storage.html#c6">reverse_orientation</a>(<font class="keywordtype">unsigned</font> start, <font class="keywordtype">unsigned</font> end);
00204 
00205 
00206     <font class="keyword">private</font>:
<a name="l00207"></a><a class="code" href="classagg_1_1path__storage.html#o0">00207</a>         <font class="keywordtype">unsigned</font>        <a class="code" href="classagg_1_1path__storage.html#o0">m_total_vertices</a>;
<a name="l00208"></a><a class="code" href="classagg_1_1path__storage.html#o1">00208</a>         <font class="keywordtype">unsigned</font>        <a class="code" href="classagg_1_1path__storage.html#o1">m_total_blocks</a>;
<a name="l00209"></a><a class="code" href="classagg_1_1path__storage.html#o2">00209</a>         <font class="keywordtype">unsigned</font>        <a class="code" href="classagg_1_1path__storage.html#o2">m_max_blocks</a>;
<a name="l00210"></a><a class="code" href="classagg_1_1path__storage.html#o3">00210</a>         <font class="keywordtype">double</font>**        <a class="code" href="classagg_1_1path__storage.html#o3">m_coord_blocks</a>;
<a name="l00211"></a><a class="code" href="classagg_1_1path__storage.html#o4">00211</a>         <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>** <a class="code" href="classagg_1_1path__storage.html#o4">m_flag_blocks</a>;
<a name="l00212"></a><a class="code" href="classagg_1_1path__storage.html#o5">00212</a>         <font class="keywordtype">unsigned</font>        <a class="code" href="classagg_1_1path__storage.html#o5">m_iterator</a>;
<a name="l00213"></a><a class="code" href="classagg_1_1path__storage.html#o6">00213</a>         <a class="code" href="namespaceagg.html#a64">orientation_e</a>   <a class="code" href="classagg_1_1path__storage.html#o6">m_cur_orient</a>;
00214     };
00215 
00216 
00217 
00218     <font class="comment">//------------------------------------------------------------------------</font>
00219     <font class="keyword">inline</font> <font class="keywordtype">unsigned</font>
<a name="l00220"></a><a class="code" href="classagg_1_1path__storage.html#c0">00220</a>     path_storage::get_vertex_with_flags(<font class="keywordtype">unsigned</font> idx, <font class="keywordtype">double</font>* x, <font class="keywordtype">double</font>* y)<font class="keyword"> const</font>
00221 <font class="keyword">    </font>{
00222         <font class="keyword">register</font> <font class="keywordtype">unsigned</font> nb = idx &gt;&gt; <a class="code" href="classagg_1_1path__storage.html#u4u0">block_shift</a>;
00223         <font class="keyword">register</font> <font class="keywordtype">double</font>*  pv = <a class="code" href="classagg_1_1path__storage.html#o3">m_coord_blocks</a>[nb] + ((idx &amp; <a class="code" href="classagg_1_1path__storage.html#u4u2">block_mask</a>) &lt;&lt; 1);
00224         *x = *pv++;
00225         *y = *pv;
00226         <font class="keywordflow">return</font> <a class="code" href="classagg_1_1path__storage.html#o4">m_flag_blocks</a>[nb][idx &amp; <a class="code" href="classagg_1_1path__storage.html#u4u2">block_mask</a>];
00227     }
00228 
00229 
00230 
00231     <font class="comment">//------------------------------------------------------------------------</font>
00232     <font class="keyword">inline</font> <a class="code" href="namespaceagg.html#a63">pathflag_e</a> 
<a name="l00233"></a><a class="code" href="classagg_1_1path__storage.html#a13">00233</a>     path_storage::get_vertex(<font class="keywordtype">unsigned</font> idx, <font class="keywordtype">double</font>* x, <font class="keywordtype">double</font>* y)<font class="keyword"> const</font>
00234 <font class="keyword">    </font>{
00235         <font class="keywordflow">return</font> <a class="code" href="namespaceagg.html#a63">pathflag_e</a>(<a class="code" href="classagg_1_1path__storage.html#c0">get_vertex_with_flags</a>(idx, x, y) &amp; 0xF);
00236     }
00237 
00238 
00239     <font class="comment">//------------------------------------------------------------------------</font>
<a name="l00240"></a><a class="code" href="classagg_1_1path__storage.html#a16">00240</a>     <font class="keyword">inline</font> <a class="code" href="namespaceagg.html#a63">pathflag_e</a> path_storage::next_vertex(<font class="keywordtype">double</font>* x, <font class="keywordtype">double</font>* y)
00241     {
00242         <font class="keywordflow">if</font>(<a class="code" href="classagg_1_1path__storage.html#o5">m_iterator</a> &gt;= <a class="code" href="classagg_1_1path__storage.html#o0">m_total_vertices</a>) <font class="keywordflow">return</font> <a class="code" href="namespaceagg.html#a63a25">pathflag_stop</a>;
00243         <font class="keyword">register</font> <font class="keywordtype">unsigned</font> flags = <a class="code" href="classagg_1_1path__storage.html#c0">get_vertex_with_flags</a>(<a class="code" href="classagg_1_1path__storage.html#o5">m_iterator</a>++, x, y);
00244         <font class="keywordflow">if</font>((flags &amp; 0xF) == <a class="code" href="namespaceagg.html#a63a26">pathflag_move_to</a>)
00245         {
00246             <a class="code" href="classagg_1_1path__storage.html#o6">m_cur_orient</a> = <a class="code" href="namespaceagg.html#a64">orientation_e</a>(flags &amp; (<a class="code" href="namespaceagg.html#a64a32">orientation_cw</a> | <a class="code" href="namespaceagg.html#a64a31">orientation_ccw</a>));
00247         }
00248         <font class="keywordflow">return</font> <a class="code" href="namespaceagg.html#a63">pathflag_e</a>(flags &amp; 0xF);
00249     }
00250 
00251 
00252     <font class="comment">//------------------------------------------------------------------------</font>
<a name="l00253"></a><a class="code" href="classagg_1_1path__storage.html#c4">00253</a>     <font class="keyword">inline</font> <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>* path_storage::get_storage_ptrs(<font class="keywordtype">double</font>** xy_ptr)
00254     {
00255         <font class="keyword">register</font> <font class="keywordtype">unsigned</font> nb = <a class="code" href="classagg_1_1path__storage.html#o0">m_total_vertices</a> &gt;&gt; <a class="code" href="classagg_1_1path__storage.html#u4u0">block_shift</a>;
00256         <font class="keywordflow">if</font>(nb &gt;= <a class="code" href="classagg_1_1path__storage.html#o1">m_total_blocks</a>)
00257         {
00258             <a class="code" href="classagg_1_1path__storage.html#c3">allocate_block</a>(nb);
00259         }
00260         *xy_ptr = <a class="code" href="classagg_1_1path__storage.html#o3">m_coord_blocks</a>[nb] + ((<a class="code" href="classagg_1_1path__storage.html#o0">m_total_vertices</a> &amp; <a class="code" href="classagg_1_1path__storage.html#u4u2">block_mask</a>) &lt;&lt; 1);
00261         <font class="keywordflow">return</font> <a class="code" href="classagg_1_1path__storage.html#o4">m_flag_blocks</a>[nb] + (<a class="code" href="classagg_1_1path__storage.html#o0">m_total_vertices</a> &amp; <a class="code" href="classagg_1_1path__storage.html#u4u2">block_mask</a>);
00262     }
00263 
00264 
00265     <font class="comment">//------------------------------------------------------------------------</font>
<a name="l00266"></a><a class="code" href="classagg_1_1path__storage.html#a21">00266</a>     <font class="keyword">inline</font> <font class="keywordtype">void</font> path_storage::add_vertex(<font class="keywordtype">double</font> x, <font class="keywordtype">double</font> y, <font class="keywordtype">unsigned</font> flags)
00267     {
00268         <font class="keywordtype">double</font>* coord_ptr = 0;
00269         <font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>* flag_ptr = <a class="code" href="classagg_1_1path__storage.html#c4">get_storage_ptrs</a>(&amp;coord_ptr);
00270         *flag_ptr = (<font class="keywordtype">unsigned</font> <font class="keywordtype">char</font>)flags;
00271         *coord_ptr++ = x;
00272         *coord_ptr   = y;
00273         <a class="code" href="classagg_1_1path__storage.html#o0">m_total_vertices</a>++;
00274     }
00275 
00276     <font class="comment">//------------------------------------------------------------------------</font>
<a name="l00277"></a><a class="code" href="classagg_1_1path__storage.html#a4">00277</a>     <font class="keyword">inline</font> <font class="keywordtype">void</font> path_storage::move_to(<font class="keywordtype">double</font> x, <font class="keywordtype">double</font> y, 
00278                                       <a class="code" href="namespaceagg.html#a64">orientation_e</a> orient)
00279     {
00280         <a class="code" href="classagg_1_1path__storage.html#a21">add_vertex</a>(x, y, <a class="code" href="namespaceagg.html#a63a26">pathflag_move_to</a> | orient);
00281     }
00282 
00283 
00284     <font class="comment">//------------------------------------------------------------------------</font>
<a name="l00285"></a><a class="code" href="classagg_1_1path__storage.html#a5">00285</a>     <font class="keyword">inline</font> <font class="keywordtype">void</font> path_storage::line_to(<font class="keywordtype">double</font> x, <font class="keywordtype">double</font> y)
00286     {
00287         <a class="code" href="classagg_1_1path__storage.html#a21">add_vertex</a>(x, y, <a class="code" href="namespaceagg.html#a63a27">pathflag_line_to</a>);
00288     }
00289 
00290 
00291 
00292 
00293 
00294 
00295 }
00296 
00297 
00298 
00299 <font class="preprocessor">#endif</font>
</pre></div><hr><address><small>Generated on Tue Apr 23 09:06:33 2002 for AGG v2.0 beta by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.gif" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.14 written by <a href="mailto:dimitri@stack.nl">Dimitri van Heesch</a>,
 &copy;&nbsp;1997-2002</small></address>
</body>
</html>
